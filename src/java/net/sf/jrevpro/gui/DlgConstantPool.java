/**
 * JReversePro - Java Decompiler / Disassembler.
 * Copyright (C) 2008 Karthik Kumar.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *  
 *  	http://www.apache.org/licenses/LICENSE-2.0 
 *  
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/
package net.sf.jrevpro.gui;

import javax.swing.JScrollPane;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JScrollBar;

import net.sf.jrevpro.reflect.ConstantPool;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseEvent;

import java.awt.BorderLayout;
import java.awt.Dimension;

/**
 * JCpDialog is the Dialog containing the ConstantPool contents.
 * 
 * @author Karthik Kumar
 * @version 1.3
 **/
@SuppressWarnings("serial")
public class DlgConstantPool extends JDialog implements ActionListener,
    MouseListener {

  /**
   * @param aParent
   *          Parent Frame
   * @param aClassName
   *          Name of the Class/interface.
   * @param aCpInfo
   *          Constant Pool information.
   **/
  public DlgConstantPool(JFrame aParent, String aClassName, ConstantPool aCpInfo) {

    super(aParent, "ConstantPool: " + aClassName, true);

    mEntries = aCpInfo.getMaxCpEntry();

    mCpTable = new TableConstantPool(aCpInfo);
    mPnlList = new CustomListPanel(mEntries);
    mScrPoolData = new JScrollPane(mCpTable);

    setLocation(100, 100);
    setSize(600, 225);

    // addComponents
    getContentPane().setLayout(new BorderLayout());
    getContentPane().add(mPnlList, BorderLayout.NORTH);

    mScrPoolData.setPreferredSize(new Dimension(400, 100));
    getContentPane().add(mScrPoolData, BorderLayout.SOUTH);

    setResizable(false);

    mPnlList.mBtnFind.addActionListener(this);
    mPnlList.mBtnGoto.addActionListener(this);

    mCpTable.addMouseListener(this);

    addWindowListener(new DlgClose());
  }

  /**
   * ActionListener method.
   * 
   * @param aEvent
   *          Event generated by the ActionListener.
   **/
  public void actionPerformed(ActionEvent aEvent) {
    if (aEvent.getSource() == mPnlList.mBtnFind) {
      findText();
    } else if (aEvent.getSource() == mPnlList.mBtnGoto) {
      gotoIndex(getCpIndex());
    }
  }

  /**
   * MouseListener method.
   * 
   * @param aEvent
   *          Event generated by the MouseListener
   **/
  public void mouseClicked(MouseEvent aEvent) {
    if (aEvent.getSource() == mCpTable) {
      int SelRow = mCpTable.getSelectedRow();
      int SelCol = mCpTable.getSelectedColumn();
      Object Obj = mCpTable.getValueAt(SelRow, SelCol);
      if (Obj instanceof Integer) {
        int IntValue = ((Integer) (Obj)).intValue();
        gotoIndex(IntValue);
      }
    }
  }

  /**
   * MouseListener method.
   * 
   * @param aEvent
   *          Event generated by the MouseListener
   **/
  public void mouseEntered(MouseEvent aEvent) {
  }

  /**
   * MouseListener method.
   * 
   * @param aEvent
   *          Event generated by the MouseListener
   **/
  public void mouseExited(MouseEvent aEvent) {
  }

  /**
   * MouseListener method.
   * 
   * @param aEvent
   *          Event generated by the MouseListener
   **/
  public void mousePressed(MouseEvent aEvent) {
  }

  /**
   * MouseListener method.
   * 
   * @param aEvent
   *          Event generated by the MouseListener
   **/
  public void mouseReleased(MouseEvent aEvent) {
  }

  /**
   * Looks for the specified text in the ConstantPool entries. Not yet
   * implemented.
   **/
  private void findText() {

  }

  /**
   * Shifts the focus of the Table view of the ConstantPool to the entry
   * beginning with aTargetIndex.
   * 
   * @param aTargetIndex
   *          Index of the ConstantPool to be moved to.
   **/
  private void gotoIndex(int aTargetIndex) {
    int StepValue;
    int StartValue;

    JScrollBar VBar = mScrPoolData.getVerticalScrollBar();
    StepValue = (VBar.getMaximum() - VBar.getMinimum()) / mEntries;
    StartValue = VBar.getMinimum();
    VBar.setValue(StartValue + aTargetIndex * StepValue);
  }

  /**
   * Validates the data entered as ConstantPool and returns the information.
   * 
   * @return the Index of the ConstantPool to be sought after.
   **/
  private int getCpIndex() {
    int InputValue;

    try {
      InputValue = Integer.parseInt(mPnlList.mTxtIndex.getText());

      if (InputValue <= 0) {
        return 0;
      } else if (InputValue >= mEntries) {
        return mEntries;
      } else {
        return InputValue;
      }
    } catch (Exception e) {
      return 0;
    }
  }

  /**
   * mCpTable Table representation of ConstantPool
   **/
  private TableConstantPool mCpTable;

  /**
   * mScrPoolData ScrollPane view for the Table mCpTable.
   **/
  private JScrollPane mScrPoolData;

  /**
   * mPnlList Panel containing the buttons to propagate across the pointers of
   * the ConstantPool.
   **/
  private CustomListPanel mPnlList;

  /**
   * mEntries Maximum number of ConstantPoolEntries.
   **/
  private int mEntries;
}
